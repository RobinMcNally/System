typeset -U PATH # Prevents duplicate PATH entries. zsh only, so it's set prior to sourcing anything that might set PATH.

source $HOME/.profile

HISTFILE=$HOME/.zsh_history
setopt APPEND_HISTORY
HISTSIZE=1200
SAVEHIST=1000
setopt HIST_EXPIRE_DUPS_FIRST
setopt HIST_IGNORE_DUPS
#setopt EXTENDED_HISTORY
setopt HIST_IGNORE_SPACE
setopt PROMPT_SUBST

autoload -U colors && colors

set -o emacs # I just cannot get used to vim bindings on the shell, they're clunky. Disabling since EDITOR would set it.

# These force vim-style behavior, rather than vi-style. Screw vi.
#bindkey "^?" backward-delete-char
#bindkey "^W" backward-kill-word
#bindkey "^H" backward-delete-char
#bindkey "^U" kill-line

# Autocompletions
autoload -Uz compinit
compinit

zstyle ':completion:*' auto-description 'specify: %d'
zstyle ':completion:*' completer _expand _complete _ignored _correct _approximate
zstyle ':completion:*' completions 1
zstyle ':completion:*' expand prefix suffix
zstyle ':completion:*' file-sort modification
zstyle ':completion:*' format '%F{blue}Completing %d%f'
zstyle ':completion:*' glob 1
zstyle ':completion:*' group-name ''
zstyle ':completion:*' ignore-parents parent ..
zstyle ':completion:*' insert-unambiguous true
zstyle ':completion:*' list-colors ''
zstyle ':completion:*' list-suffixes true
zstyle ':completion:*' matcher-list '+' '+m:{[:lower:]}={[:upper:]}' '+r:|[._-]=** r:|=**' '+'
zstyle ':completion:*' max-errors 3
zstyle ':completion:*' menu select=0
zstyle ':completion:*' original false
zstyle ':completion:*' prompt 'Corrections (%e):'
zstyle ':completion:*' select-prompt %SScrolling active: current selection at %p%s
zstyle ':completion:*' squeeze-slashes true
zstyle ':completion:*' substitute 1
zstyle ':completion:*' verbose true

h=()
if [[ -r ~/.ssh/config ]]; then
    h=($h ${${${(@M)${(f)"$(cat ~/.ssh/config)"}:#Host *}#Host }:#*[*?]*})
fi
if [[ $#h -gt 0 ]]; then
    zstyle ':completion:*:ssh:*' hosts $h
    zstyle ':completion:*:slogin:*' hosts $h
fi

# Sensitive environment variables (so they aren't stored in the public repo)
[[ -f "$HOME/.mac_addr" ]] && source "$HOME/.mac_addr"

# General aliases
alias tmx='tmux new-session -A -s $USER'
alias src='source $HOME/.zshrc'
alias xcode='open *.xcworkspace || open *.xcodeproj' # Stolen from http://www.codeography.com/2009/10/28/open-xcode-project-from-the-command-line.html

# Homebrew aliases for funsies: (Hat tip @jwisser)
alias grab='brew install'
alias toss='brew uninstall'

alias gitmx='tmux new-session -A -s git-status'
alias cups-pipsqueak='open "http://localhost:2000" && ssh pipsqueak -L 2000:pipsqueak:631 -N'

# Colorful ls!
if [ $(uname) = "Linux" ]; then
    # Linux
    alias ls='ls -F --color=auto'
    export LS_COLORS='di=33:fi=0:ln=35:pi=34:so=36:bd=7;32:cd=32:or=37:mi=0:ex=31'
else
    # OS X   
    alias ls='ls -FG'
    export LSCOLORS=dxfxgxexbxxccxBxBxdADA
    export CLICOLOR=1
fi

# Functions

cdls () {
    if [[ -z $2 ]]; then
        cd $1 && ls
    else
        cd $2 && ls $1
    fi
}

count_git_items () {
    echo "$1" | awk "{c+=gsub(/$2/,\"\")} END{print c+0}"
}

build_prompt () {
    if $(git branch 1> /dev/null 2>&1); then
        # We're in a git repo, so activate the special prompt.
        git_name=$(git config user.name)
        repo_name=$(basename $(git rev-parse --show-toplevel))

        subpath=$(git rev-parse --show-prefix)
        [ -n "$subpath" ] && subpath="/$subpath" # Only display a slash if we're actually in a subdirectory.

        unstage_status=""
        stage_status=""

        git_status=$(git status --short --branch)

        branch=$(echo "$git_status" | grep "^##" | cut -f 2- -d ' ')

        untracked=$(count_git_items $git_status "^\?\?")
        [ $untracked -ne 0 ] && unstage_status="$unstage_status %F{magenta}+$untracked"

        modified_unstaged=$(count_git_items $git_status "^.M")
        [ $modified_unstaged -ne 0 ] && unstage_status="$unstage_status %F{magenta}~$modified_unstaged"

        deleted_unstaged=$(count_git_items $git_status "^.D")
        [ $deleted_unstaged -ne 0 ] && unstage_status="$unstage_status %F{magenta}-$deleted_unstaged"
       
        added_staged=$(count_git_items $git_status "^A")
        [ $added_staged -ne 0 ] && stage_status="$stage_status %F{green}+$added_staged"

        modified_staged=$(count_git_items $git_status "^[MR]")
        [ $modified_staged -ne 0 ] && stage_status="$stage_status %F{yellow}~$modified_staged"

        deleted_staged=$(count_git_items $git_status "^D")
        [ $deleted_staged -ne 0 ] && stage_status="$stage_status %F{red}-$deleted_staged"

        divider=""
        [[ -n $unstage_status ]] && [[ -n $stage_status ]] && divider="%B%F{black} //%f%b"
        [[ -z $unstage_status ]] && [[ -z $stage_status ]] && divider="%B%F{black} ✓%f%b"

        branch="%F{blue}$branch"

        PROMPT="%B%F{black}$git_name ± %f%b%F{yellow}$repo_name%f%B%F{black}$subpath ⋋ %b$branch%B%F{black} [%b$unstage_status$divider$stage_status %B%F{black}]%b
%(#.%B%F{red}.%F{blue})>> %f%b"
    else
        PROMPT="%B%(#.%F{red}ROOT%f.%F{black}%n)%F{black} @ %m : %f%b%F{yellow}%d%f %1(j.%F{cyan}⎇  %j%f.)
%(#.%B%F{red}.%F{blue})>> %f%b"
    fi
}

precmd () {
    build_prompt
}

# Right-hand prompt is always the same:

# Display the exit status of the last command as a green/red status light, and
# print out the code if it's > 0.
RPROMPT="%(?.%F{green}.%F{red}%? )%{%G•%}%f"
